# 10.1 什么是关联规则学习？

## 基本概念

### 关联规则学习的定义

- 关联规则学习 (Association Rule Mining) 是一种无监督学习机器学习方法，用于从无标签数据中挖掘特定的关联模式。

### 项集与数据库

- 项集 (Itemset)：包含N个不同项 (Item) 的集合，$I=\{i_{1}, i_{2}, ..., i_{N}\}$。
- 数据库 (Database)：包含T条记录，$D=\{I_{1}, I_{2}, ..., I_{T}\}$，每条记录由一个项集组成。

### 关联规则

- 表示两个项集的关联，形如 $X \Rightarrow Y$。
  - $X$：先决条件 (Antecedent) 为一个项集；
  - $Y$：关联结果 (Consequent) 为一个项集。

### 关联规则的评价指标

- 支持计数 (Support count, σ)：某个项集出现的次数，例如$\sigma(\{面包, 牛奶\})=3$。
- 支持度 (Support, s)：$s=P(X \cup Y)$，即关联规则中两个项集的并集在数据库中出现的频率，公式为：
$$s(\{面包, 牛奶\})=\frac{\sigma(\{面包, 牛奶\})}{数据库大小}$$
- 置信度 (Confidence, c)：$c=P(Y | X)$，代表关联规则的先决条件X发生的情况下，关联结果Y发生的概率，以关联规则R:{牛奶, 啤酒}⇒{尿布}为例，公式为：
$$c(R)=\frac{\sigma(\{牛奶, 尿布, 啤酒\})}{\sigma(\{牛奶, 啤酒\})}$$

### 核心目标

从数据库中寻找具有较高支持度（并集出现频率高）和置信度（条件情况下结果发生的概率）的关联规则。

## 应用场景

- 购物篮分析：挖掘哪些商品经常被一同购买，商家可据此安排货物位置。
- 医疗临床诊断：在医疗日志中发现症状与疾病之间的关联，例如注意力不集中、头疼、失眠一起出现时可能与高血压关联。
- 网络安全分析：发现恶意攻击的行为关联，例如用户扫描特定端口、认证失败后尝试修改策略，可能与攻击行为关联。
- 分子性质分析：挖掘分子结构与其性质之间的潜在关联，例如分子中的官能团、化学键等特征与药理特性、亲水性等性质的关联。

## 代表性方法

### 核心问题

如何找到频繁出现的项集？频繁出现的项集往往蕴含关联规则。

### 方法分类

基于数据的类别，关联规则学习方法可分为表数据算法和图数据算法：
- 表数据算法：可处理如交易记录、操作日志等表结构数据，典型算法包括Apriori算法、Eclat算法、FP-growth算法。
- 图数据算法：可处理如社交网络图、分子图等图结构数据，典型算法包括FSG算法、gSpan算法。

# 10.2 先验算法

## 先验算法的原理

### 先验算法的定义

- 定义：先验算法 (Apriori Algorithm)是一种经典的关联规则学习方法，用于从基于表的形式的数据库中提取频繁项集。
- 频繁项集：数据集中频繁出现的数据集合，在实际应用中，如果一个项集的支持度高于设定的支持度阈值，则认为该项集是频繁项集。
- 先验算法vs.蛮力搜索：蛮力搜索实现简单但计算复杂度很高，难以应用于较大规模数据库的频繁项集挖掘；先验算法则可以大幅降低频繁项集的搜索规模，避免了大量不必要的数据检索，在处理大规模数据集时更加高效。

### 蛮力搜索的缺陷

- 方法：将所有的项集作为频繁项集的候选，并扫描数据库统计每个候选的支持度。
- 缺陷：频繁项集候选的数量随项的数量呈指数级增长，且遍历数据库的时间随着数据库增大而延长，导致蛮力搜索具有极高的计算复杂度。

### 主要思想

- 先验原则：如果一个项集是频繁项集，则其子集一定是频繁项集。反之，如果一个项集的某个子集不是频繁项集，则该项集一定不是频繁项集。
- 核心作用：利用先验原则对搜索过程进行剪枝，减少频繁项集候选数量，提高检索效率。

### 先验原则的推导

- 如果项集X是项集Y的子集，则在数据库中，包含Y的记录必然包含X。
- 记X和Y的支持度分布为$s(X)$，$s(Y)$，则有：
$$\forall X, Y:(X \subseteq Y) \Rightarrow s(X) \geq s(Y)$$
- 若Y是频繁项集，则有$s(X) \geq s(Y) \geq S_{th}$，其中$S_{th}$表示频繁项集的支持度阈值，故X也是频繁项集。

### 基于先验原则的剪枝

如果AB不是频繁项集，则包含AB的项集也一定不是频繁项集，从而起到剪枝的作用。

## 先验算法的流程

### 核心步骤

1. 挖掘频繁项集
   - 初始化：设置$k=1$，生成长度为1的频繁项集。
   - 重复以下步骤直到没有新的频繁项集被找到：
     - 从长度为k的频繁项集生成长度为k+1的频繁项集候选；
     - 从长度为k+1的频繁项集候选中删除包含长度为k的非频繁项集的候选；
     - 扫描数据集，统计剩余的频繁项集候选的支持度；
     - 删除非频繁的候选项集，$k=k+1$。
2. 导出关联规则并计算指标

### 关联规则的评价指标

- 支持度：$s(X)=\sigma(X) /|D|$，其中$\sigma(X)$是包含X的交易数量，$|D|$表示数据库中所有交易的数量。
- 置信度：$c(X \to Y)=s(X \cup Y) / s(X)$。
- 提升度：$l(X \to Y)=s(X \cup Y) /(s(X) \times s(Y))$，提升度大于1则表示关联规则有效。

## 先验算法的局限

- 对参数敏感：受支持度阈值影响大，如果支持度阈值数值过小，则先验算法筛选出的频繁项集的数量会增多，计算量过大；如果支持度阈值数值过大，则会导致结果过于稀疏，无法充分获取有价值的关联规则。
- 计算成本高：先验算法需要多次访问数据库以统计长度不同的项集的支持度，随着项集的长度增加，候选项集的数量快速增加，导致计算成本显著提高，不利于处理大规模数据集。
- 内存开销大：先验算法在生成候选集的过程中需要存储大量的中间结果，如果数据库中的频繁项集较多，则先验算法所需的内存消耗也会很大。

## 先验算法的改进

### FP-growth算法

- 核心思路：将表数据转化为FP-tree，高度压缩数据库信息，在FP-tree上挖掘出频繁项集。
- 特点：仅需两次扫描数据库，采用分治的策略有效降低搜索开销。

### ECLAT算法

- 核心思路：将数据库记录转化为以项为单位的垂直列表，通过交集运算高效挖掘频繁项集。
- 特点：仅需要一次扫描数据库，在处理大规模数据集时表现出色。

# 10.3 基于图的关联规则挖掘

## 基本概念

### 基于图的算法 vs 基于表的算法

- 传统的关联规则挖掘通常应用于表数据 (即项与项集)，然而，许多实际问题的数据具有复杂关系，通常被表示为图数据。
- 基于图的关联规则挖掘核心问题为挖掘图中的频繁子图。
- 基于图的算法扩展了传统方法的应用范围，能够以子图的形式捕捉频繁出现的数据，使其能够处理社交网络、分子结构等具有复杂结构的数据。

### 图与子图相关定义

#### 图 (Graph)

- 一个图G可以表示为一个二元组 $G=\langle V, E \rangle$，其中 $V=\{v_{1}, v_{2}, ..., v_{n}\}$ 是点集，$E=\{(v_{i}, v_{j}) | v_{i}, v_{j} \in V, i \neq j\}$ 是边集，$(v_{i}, v_{j})$ 表示节点 $v_{i}$ 和 $v_{j}$ 之间有一条边；在有向图和无向图中 $(v_{i}, v_{j})$ 分别为有序对和无序对。

#### 子图 (Subgraph)

- 一个图 $G'=\langle V', E' \rangle$ 是图 $G=\langle V, E \rangle$ 的子图当且仅当 $V' \subseteq V$ 且 $E' \subseteq E$，记为 $G' \subseteq G$，并称G包含$G'$。
- 边集大小为N的子图称为一个N-子图。

#### 连通图 (Connected Graph)

- 图中任意两点之间都存在有路径可以到达。

#### 频繁子图 (Frequent Subgraph)

- 支持度：和项集支持度的定义类似，图G作为子图在图集 $D=\{G_{1}, G_{2}, ..., G_{n}\}$ 中出现频率为图G的支持度，公式为：
$$s(G)=\frac{|D_{G}|}{|D|}$$
其中 $D_{G}=\{G_{i} | G \subseteq G_{i}, G_{i} \in D\}$。
- 频繁子图：支持度大于等于阈值 $S \in (0,1]$ 的连通图称为频繁子图。

### 标记图 (Labeled Graph)

#### 定义

- 图除了包含点集边集外，在点或边上存在标记值或称权值 (标记值可以重复)，这类图被称为标记图，记为 $G=\langle V, E, l \rangle$。

#### 同构 (Isomorphism)

- 两个点标记图 $G_{1}=\langle V_{1}, E_{1}, l_{1} \rangle$、$G_{2}=\langle V_{2}, E_{2}, l_{2} \rangle$ 同构当且仅当存在一个一一映射 $f: V_{1} \to V_{2}$ 使得：
  1. 任取 $u \in V_{1}$，$l_{1}(u)=l_{2}(f(u))$；
  2. 任取 $u, v \in V_{1}$，$(u, v) \in E_{1}$ 当且仅当 $(f(u), f(v)) \in E_{2}$。
- 在标记图中，仅关注图中的标记值而非点的序号本身，两个同构的图不相等但具有相同的信息。

#### 子图同构 (Subgraph Isomorphism)

- 如果 $G_{i}$ 存在子图 $G_{i}'$ 和图G同构，则称 $G_{i}$ 包含G，或 $G_{i}$ 子图同构于G。
- 子图同构是NP-完全问题。

## FSG算法

### 什么是FSG算法?

- FSG算法是基于先验算法的频繁子图挖掘算法，从图形式的数据中挖掘频繁子图。
- FSG算法定义：给定图集合 $D=\{G_{1}, G_{2}, ..., G_{n}\}$（$G_{i}=\langle V_{i}, E_{i} \rangle$）和支持度阈值S，找到所有满足条件 $s(G) \geq S$ 的连通图G。
- 核心思想：和表形式的先验算法类似，FSG算法从最小的子图 (1-子图) 开始搜索频繁子图，再通过不断增大候选子图找到所有大小的频繁子图。

### FSG算法流程（无标记图）

- 输入：图集 $D=\{G_{i}\}$，支持度阈值S；
- 输出：频繁子图集合F；
- 步骤1. 初始化：$k=1$，搜索图集筛选出所有频繁k-子图 $F_{k}=\{G_{i}'\}$；
- 步骤2. 子图扩展：将k-子图两两合并得到连通的候选的 $(k+1)$-子图；
- 步骤3. 剪枝：在候选子图中删掉至少包含一个非频繁连通k-子图的 $(k+1)$-子图；
- 步骤4. 验证支持度：计算支持度筛选出所有频繁 $(k+1)$-子图，$k \leftarrow k+1$；
- 步骤5. 重复执行：重复步骤2-4直到频繁k-子图的数量为0（$F_{k}=\emptyset$）；
- 步骤6. 返回结果：$F=F_{1} \cup F_{2} \cup ... \cup F_{k}$。

### FSG算法流程（标记图）

- 输入：图集 $D=\{G_{i}=\langle V_{i}, E_{i}, l_{i} \rangle\}$，支持度阈值S；
- 输出：频繁子图集合F；
- 步骤1. 初始化：$k=1$，搜索图集筛选出所有频繁k-子图 $F_{k}=\{G_{i}'\}$；
- 步骤2. 子图扩展：将k-子图两两合并去重得到连通的候选的 $(k+1)$-子图；
- 步骤3. 剪枝：在候选子图中删掉子图同构于任意非频繁连通k-子图的子图；
- 步骤4. 验证支持度：计算支持度筛选出所有频繁 $(k+1)$-子图，$k \leftarrow k+1$；
- 步骤5. 重复执行：重复步骤2-4直到频繁k-子图的数量为0（$F_{k}=\emptyset$）；
- 步骤6. 返回结果：$F=F_{1} \cup F_{2} \cup ... \cup F_{k}$。
- 关键问题：步骤2涉及图同构判断去重，步骤3、4涉及子图同构判断。

### FSG算法的应用示例

- 社交网络分析：某社交平台有5个独立的社交网络 $\{G_{1}, G_{2}, ..., G_{5}\}$（对应音乐、体育、学习、电影、美食5个主题），账号间存在"互动"边，通过FSG挖掘频繁子图，推测用户成为好友的可能性。

## gSpan算法

### FSG算法的缺点

- 在对标记图进行频繁子图挖掘时，需要解决图同构判断去重和子图同构判断两个高复杂度问题，运行效率较低。

### 什么是gSpan算法?

- gSpan算法 (Graph-based Substructure Pattern Mining) 是一种基于深度优先搜索 (DFS) 策略的频繁子图挖掘算法。
- 核心优势：通过定义图的最小DFS编码来避免生成冗余的候选同构子图，显著提高了挖掘效率，是频繁子图挖掘中最为经典的算法之一。